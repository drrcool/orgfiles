#+Title: Emacs Configuration
#+PROPERTY: header-args :tangle ~/.dotfiles/emacs/config.el
#+PROPERTY: header-args :results none
#+auto_tangle: true


* About this config
This is my first attempt at a fully-feature emacs configuration. In many ways, I have little idea of what I'm doing. I've used emacs for years without these features, but with the advent of LSP would like to learn more about to make emacs work the best for my workflow as possible. I've learned a lot via DOOM emacs, but now I want to ensure I have a system that caters to my personal need.

* Setup:
We need to tell emacs to use the literate config file instead of a traditional init.el.  I still tangle this file, mainly for debugging later. But thats's likely not needed.
#+begin_src emacs-lisp :tangle ~/.dotfiles/emacs/init.el
    (org-babel-load-file
     (expand-file-name
      "config.org"
      user-emacs-directory))
  #+end_src

* Initial Quick setup
These are the random one-off configurations that help make Emacs better, but didn't fall into a great category.  Things like removing the unneeded ui elements from the screen or suppressing annoying dialogs that you always answer yes to.
**** Remove some of the features of the UI that we don't need (toolbars, menubars, scroll bars, and splash screen)
#+BEGIN_SRC emacs-lisp 
;; Don't show the splash screen
(setq inhibit-startup-message t)
;; Turn off some unneeded UI Elements
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

#+RESULTS:
**** Suppress emacs from asking if it should follow symlink files
#+begin_src emacs-lisp :tangle yes
(setq vc-follow-symlinks t)
  #+end_src
**** Turn on line numbers
#+BEGIN_SRC emacs-lisp 
  ;; Turn on line numbers in every buffer
  (global-display-line-numbers-mode 1)
  ;; With vim bindings, relatives let us use j and k better
  (setq display-line-numbers-type 'relative)
#+END_SRC

**** Disable lockfiles
#+begin_src emacs-lisp 
 
(setq create-lockfiles nil)
  #+end_src

**** Separate third-party customization
#+begin_src emacs-lisp 
 
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file t)
  #+end_src

**** Small UI Tweaks


#+BEGIN_SRC emacs-lisp 
;; Turn on line highlithting for current line
(hl-line-mode 1)
;; Add some margins
(set-fringe-mode 10)
#+END_SRC

**** Add escape to kill prompts

#+BEGIN_SRC emacs-lisp 
;; Make escape kill prompts
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)

#+END_SRC
* Setup our package manager
** Define where we go for packages

#+BEGIN_SRC emacs-lisp 
    ;; Configure pacakge manager
    (require 'package)
    (setq package-archives '(("melpa" . "https://melpa.org/packages/")
			     ("org" . "https://orgmode.org/elpa/")
			     ("elpa" . "https://elpa.gnu.prg/packages")
			     ))

 (package-initialize)
    (unless package-archive-contents
      (package-refresh-contents))

#+END_SRC


** Setup use-package

#+BEGIN_SRC emacs-lisp 
;;Initalize use-package
(unless (package-installed-p 'use-package)
(package-install 'use-package))

(require 'use-package)
(require 'quelpa-use-package)
(setq use-package-always-ensure t)

#+END_SRC

#+RESULTS:
: t

* Build the UI we want
** Themes:
*** Setup Modus Themes


I like to do this even if I don't plan on the modus themes being my main theme of choice. I often swap themes, and this way they are ready when I want them.
#+BEGIN_SRC emacs-lisp 
(use-package modus-themes
:init
(setq modus-themes-hl-line '(accented intense)
modus-themes-subtle-line-numbers nil
modus-themes-region '(accented bg-only)
modus-themes-variable-pitch-ui nil
modus-themes-fringest 'intense
modus-themes-diffs nil
modus-themes-italic-constructs t
modus-themes-bold-construct t
modus-themes-prompts '( bold intense italic)
modus-themes-intense-mouseovers t
modus-themes-paren-match '(bold intense)
modus-themes-syntax '(alt-syntax yellow-comments green-strings)
modus-themes-links '(neutral-underline background)
modus-themes-mode-line '(moody borderless accented 4 1)
modus-themes-tabs-accented nil
modus-themes-completions '((matches . (extrabold intense accented))
                           (selection . (semibold accented intense))
                           (popup . (accented)))
modus-themes-heading '((1 . (rainbow 1.4))
                       (2 . (rainbow 1.3))
                       (3 . (rainbow 1.2))
                       (4 . (rainbow bold 1.1))
                       (t . (rainbow old)))
modus-themes-org-blocks 'tinted-background
modus-themes-org-agenta '((header-block . (semibold 1.4))
                          (header-date . (workaholic bold-today 1.2))
                          (event . (accented italic varied))
                          (scheduled . rainbow)
                          (habit . traffic-light))
modus-themes-markup '(intense background)
modus-themes-mail-citations 'intensep
modus-themes-lang-checkers '(background))
:config


)




#+END_SRC

#+RESULTS:
: t
*** doom-themes
#+begin_src emacs-lisp 
  (use-package doom-themes
    :ensure t
    :config
    (setq doom-themes-enable-bold t
          doom-themes-enable-italic t)
    (load-theme 'doom-acario-dark t)

    (doom-themes-visual-bell-config)
    (doom-themes-neotree-config)
    (setq doom-themes-treemacs-theme "doom-atom")
    (doom-themes-treemacs-config)
    (doom-themes-org-config)) 

** Setup our fonts

#+BEGIN_SRC emacs-lisp 
;; Set a font
(set-face-attribute 'default nil :family "PragmataProMonoLiga Nerd Font" :height 250)

;; Proportionally spaced typeface
(set-face-attribute 'variable-pitch nil :family "Fantasque Sans Mono" :height 1.0)

;; Monospaced typeface
(set-face-attribute 'fixed-pitch nil :family "DankMono Nerd Font" :height 1.5)

#+END_SRC

#+RESULTS:

** Install a better mode line

#+BEGIN_SRC emacs-lisp 
(use-package doom-modeline
  :ensure t
  :init (doom-modeline-mode 1)
  :custom ((doom-modeline-height 20)))

(use-package all-the-icons
  :if (display-graphic-p))


#+END_SRC

** Update the help docs

#+BEGIN_SRC emacs-lisp 
(use-package helpful
  :ensure t)
(global-set-key (kbd "C-c C-d") #'helpful-at-point)
(global-set-key (kbd "C-h F") #'helpful-function)
(global-set-key (kbd "C-h C") #'helpful-command)
(setq counsel-describe-function-function #'helpful-callable)
(setq counsel-describe-variable-function #'helpful-variable)

#+END_SRC

#+RESULTS:
: helpful-variable

* Developer Interaction
This class of settings I think of as those that I need in order to work best with the editor.  How can I commicate. Plugins that affect how I communicate via keybindings, mouse, whatever should go here.


** TODO Install evil so we can function
*** TODO Install related plugins to get vim-mode features we want
**** TODO evil-surround 

#+BEGIN_SRC emacs-lisp 
  (defun rc/evil-hook ()
    (dolist (mode '(custom-mode
                    eshell-mode
                    git-rebase-mode
                    erc-mode
                    circe-server-mode
                    circe-chat-mode
                    circe-query-mode
                    sauron-mode
                    term-mode))
      (add-to-list 'evil-emacs-state-modes mode)))
		  

  (use-package evil
    :demand t
    :bind (("<escape>" . keyboard-escape-quit))
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-search-module 'evil-search)
    (setq evil-ex-complete-emacs-commands nil)
    (setq evil-vsplit-window-right t)
    (setq evil-split-window-below t)
    (setq evil-shift-round nil)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump nil)
    :hook (evil-mode . rc/evil-hook)
    :config
    (evil-mode 1)
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
    (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

    ;; Use visual line motions outside of visual line mode buffers
    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal))
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))

#+END_SRC

#+RESULTS:
: t
**** TODO evil-leader (????)
**** TODO evil-nerd-commenter
**** TODO evil-commentary
**** TODO evil-matchit
**** TODO evil-exchange
**** TODO evil-args
**** TODO evil-visualstar
**** TODO evil-dvorak
**** TODO evil-snipe
**** TODO evil-org
**** TODO evil-escape

** Change the mode line color by state
#+BEGIN_SRC emacs-lisp 
  ;; change mode-line color by evil state
    (add-hook 'post-command-hook
	      (lambda ()
		(let ((color (cond
			    ((minibufferp) '("dark gray" . "#000000"))
			    ((evil-insert-state-p) '("#e80000" . "#ffffff"))
			   ((evil-emacs-state-p)  '("#444488" . "#ffffff"))
			   ((buffer-modified-p)   '("#006fa0" . "#ffffff"))
			   (t '("dark grey" . "#000000")))))
	  (set-face-background 'mode-line (car color))
	  (set-face-foreground 'mode-line (cdr color)))))
#+END_SRC

#+RESULTS:
** Some VIM plugins
*** Vim surround

* Install org-mode

test


#+BEGIN_SRC emacs-lisp 
  (defun rc/org-mode-setup ()
    (org-indent-mode)
    (variable-pitch-mode 1)
    (auto-fill-mode 0)
    (visual-line-mode 1)
    (setq org-confirm-babel-evaluate nil)
    (setq evil-auto-indent nil))
#+END_SRC

#+RESULTS:
: rc/org-mode-setup


#+BEGIN_SRC emacs-lisp 
(use-package org
  :hook (org-mode . rc/org-mode-setup)
   :config
  (setq org-ellipsis " â–¾"
	org-hide-emphasis-markers t))

#+END_SRC

#+RESULTS:

*** Auto :tangle org files
#+begin_src emacs-lisp 
  (use-package org-auto-tangle
    :defer t
    :hook (org-mode . org-auto-tangle-mode)
    :config
    (setq org-auto-tangle-default t))
  #+end_src

  #+RESULTS:
  | evil-collection-mu4e-org-set-header-to-normal-mode | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-fold-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | org-auto-tangle-mode | rc/org-mode-setup |
		       
* Install rainbow mode
This lets us see hex colors
#+BEGIN_SRC emacs-lisp 
  (use-package rainbow-mode)
  (define-globalized-minor-mode global-rainbow-mode rainbow-mode
    (lambda ()
      (when (not (memq major-mode
		       (list 'org-agenda-mode)))
	(rainbow-mode 1))))
  (global-rainbow-mode 1)
#+END_SRC

#+RESULTS:
: t

* Yas Snippets
#+BEGIN_SRC emacs-lisp 
  (use-package yasnippet
   :config
   (setq yas-snippet-dirs '("~/.doom.d/snippets"))
   (yas-global-mode 1))
#+END_SRC

#+RESULTS:
: t

* Tree sitter
#+begin_src emacs-lisp 

  (use-package tree-sitter
    :ensure t
    :config
    (global-tree-sitter-mode)
    (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))

  (use-package tree-sitter-langs
    :ensure t
    :after tree-sitter)
  #+end_src

  #+RESULTS:
* Eglot
#+begin_src emacs-lisp 

(use-package eglot :ensure t)
  #+end_src

  #+RESULTS:

* Lua Mode
#+begin_src emacs-lisp :tangle  yes
  (use-package lua-mode
    :after Tree-sitter
    :config
    (add-to-list 'auto-mode-alist '("\\.lua\\'" . lua-mode))
    (add-to-list 'interpreter-mode-alist '("lua" . lua-mode))
  )

  #+end_src

  #+RESULTS:
* Install Company Mode
#+begin_src emacs-lisp :tangle  yes

  (use-package company

    :config
    (add-hook 'after-init-hook 'global-company-mode)

   )
  #+end_src

  #+RESULTS:
  : t

* Ivy
#+begin_src emacs-lisp 

  (use-package ivy
    :config
    (setq ivy-use-virtual-buffers t)
    (setq ivy-count-format "(%d/%d) ")
    (ivy-mode 1)
  )
  #+end_src

  #+RESULTS:
  : t

* Ivy Rich
#+begin_src emacs-lisp 

  (use-package ivy-rich
    :init
    (ivy-rich-mode 1)
   :config
   (setq ivy-format-function #'ivy-format-function-line)
   (setq ivy-rich-display-transformers-list
         (plist-put ivy-rich-display-transformers-list
                    'ivy-switch-buffer
                    '(:columns
                      ((ivy-rich-candidate (:width 40))
                       (ivy-rich-switch-buffer-indicators (:width 4 :face error :align right))
                       (ivy-rich-switch-buffer-major-mode (:width 12 :face warning))
                       (ivy-rich-switch-buffer-project (:width 15 :face success))
                       (ivy-rich-switch-buffer-path (:width (lambda(x) (ivy-rich-switch-buffer-shorten-path x (ivy-rich-minibuffer-width 0.3))))))
                      :predicate
                      (lambda (cand)
                        (if-let ((buffer (get-buffer cand)))
                            (with-current-buffer buffer
                              (not (derived-mode-p 'exwm-mode)))))))))
  #+end_src

  #+RESULTS:
  : t

* Whichy
 #+begin_src emacs-lisp 

   (use-package which-key
     :init (which-key-mode)
     :diminish which-key-mode
     :config
   (setq which-key-idle-delay 0.01))
   #+end_src  

   #+RESULTS:
   : t

* Rainbow delim
#+begin_src emacs-lisp 
  (use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
  #+end_src

  #+RESULTS:
  | rainbow-delimiters-mode |

* Key bindings with general
#+begin_src emacs-lisp 
  (use-package general
    :config
    (general-evil-setup t)

    (general-create-definer rc/leader-keys
                            :keymaps '(normal insert visual emacs)
                            :prefix "SPC"
                            :global-prefix "C-SPC"))

  (rc/leader-keys
   "t" '(:ignore t :which-key "toggles")
   "tt" '(counsel-load-theme :which-key "choose theme"))
  #+end_src

  #+RESULTS:

* hydra
#+begin_src emacs-lisp 
  (use-package hydra)
  (defhydra hydra-text-scale (:timeout 4)
            "scale text"
            ("j" text-scale-increase "in")
            ("k" text-scale-decrease "out")
            ("f" nil "finished" :exit t))
  (rc/leader-keys
    "ts" '(hydra-text-scale/body :which-key "scale text"))
  #+end_src

  #+RESULTS:

  #+end_src

  #+RESULTS:
  : t

* Typescript
#+begin_src emacs-lisp 
  (use-package typescript-mode
    :after tree-sitter
    :config
    ;; We choose this instead of tsx-mode so that eglot can automatically figure out lanaguage
    (define-derived-mode typescriptreact-mode typescript-mode "Typescript TSX")

    ;; use our derived mode for tsx files
    (add-to-list 'auto-mode-alist '("\\.tsx?\\'" . typescriptreact-mode))
    ;; by default, typescript-mode is mapped to the treesitter typescript parser
    ;; use our derived mode to map both ts and tsx -> typescriptreact-mode -> treesitter tsx
    (add-to-list 'tree-sitter-major-mode-language-alist '(typescriptreact-mode . tsx)))
 #+end_src

 #+RESULTS:
 : t

** =tsi.el= gives us tree-sitter based indentation for TS, JSON, and CSS
  #+begin_src emacs-lisp 
    (use-package tsi
      :after tree-sitter
      :quelpa (tsi :fetcher github :repo "orzechowskid/tsi.el")
      ;; define autoload definitions which when actually invoked will cause package to be loaded
      :commands (tsi-typescript-mode tsi-json-mode tsi-css-mode)
      :init
      (add-hook 'typescript-mode-hook (lambda () (tsi-typescript-mode 1)))
      (add-hook 'json-mode-hook (lambda () (tsi-json-mode 1)))
      (add-hook 'css-mode-hook (lambda () (tsi-css-mode 1)))
      (add-hook 'scss-mode-hook (lambda () (tsi-scss-mode 1))))
    #+end_src

    #+RESULTS:
    | lambda | nil | (tsi-scss-mode 1) |

** Auto-format on save
#+begin_src emacs-lisp 
  (use-package apheleia
    :ensure t
    :config
    (apheleia-global-mode +1))
 #+end_src

 #+RESULTS:
 : t

* Magit

#+begin_src emacs-lisp 
    (use-package magit
    :ensure t
    :commands (magit-status magit-get-current-branch)
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  #+end_src

  #+RESULTS:
  : t
    

